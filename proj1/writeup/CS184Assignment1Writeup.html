<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-lTUqgJg2dxbe4D7B5DEIA3jn2WilaVUapNOYl4762s');ol{margin:0;padding:0}table td,table th{padding:0}.c2{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Montserrat";font-style:normal}.c4{color:#121212;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{text-decoration-skip-ink:none;font-family:"Montserrat";-webkit-text-decoration-skip:none;font-weight:700;text-decoration:underline}.c7{color:#000000;vertical-align:baseline;font-size:11pt;font-style:normal}.c6{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{font-weight:700;text-decoration:none;font-family:"Montserrat"}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c6 doc-content"><p class="c3"><span class="c5 c7">Task 1: Drawing Single-Color Triangles</span></p><p class="c3"><span class="c1">The way that we rasterize a triangle involves sampling the center of each pixel within the framebuffer. In our case, to ensure efficiency, we create a bounded box around the triangle and test whether a sample point is within, or outside of the triangle. If the pixel is within the triangle, we make a call to fill_pixel to fill in the pixel with the appropriate color. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">To accomplish the test for the center of each pixel and whether it is inside or outside the triangle, we calculate the distance (x, y) between each pair of points, use this to dissect the plane into two planes, and if the point lies in the intersection of the same side of each line between the pair of points, then it is inside the triangle. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">We can ensure the efficiency of our algorithm because it only loops from the minimum x, y coordinates until the maximum x, y coordinates instead of the entire framebuffer. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 463.59px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c5 c7">Task 2: Antialiasing by Supersampling</span></p><p class="c3"><span class="c1">Supersampling is useful to avoid creating jaggies while rendering. This allows for a more smooth, blurred edge. Supersampling effectively mathematically creates more pixels to get an accurate representation of where the triangle lies. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The same as task 1, the way that we rasterize a triangle involves sampling the center of each pixel within the framebuffer and creating a bounded box around the triangle and test whether a sample point is within, or outside of the triangle. In the case where we supersample, we scale the buffer by the sample_rate as well as scaling the triangle at which we are sampling. Now we have more pixels within the triangle to get a more accurate representation of where the triangle lies. We effectively split the pixel into subpixels, those subpixels, if they lie within the triangle, get filled in with the color. After that, before we push the sample buffer to the framebuffer, we take the average color of all the subpixels and assign that color to the actual pixel in the framebuffer.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.50px; height: 423.84px;"><img alt="" src="images/image4.png" style="width: 566.50px; height: 423.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c1">As you can see, when the sample rate increases the edge of the triangle comes together to form the triangle rather than having random pixels filled in like you see in the top left corner.</span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c5">Task 3: Transforms</span></p><p class="c3"><span class="c1">For this task, we had to implement basic transformations (translations, scaling, and rotation). We accomplished this by filling in the 3x3 matrices that are multiplied by the vectors to achieve whatever transformation is required. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For the translation case, this means having an identity matrix, with the last column for the first two rows containing the change in x and the change in y.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For the scaling case, this means having the identity matrix, but in the first two rows having the diagonal entry be the scaling factor for the x axis in the first row, and the y in the second row.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For the rotation case, I first converted the degrees from an angle to radians by multiplying by pi/180. I then used this to fill in the rotation matrix, but for the homogeneous coordinates case (3x3). By filling in the degree, this allowed us to achieve the desired rotation.</span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 349.43px; height: 274.95px;"><img alt="" src="images/image3.png" style="width: 349.43px; height: 274.95px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 364.00px; height: 268.05px;"><img alt="" src="images/image8.png" style="width: 364.00px; height: 285.38px; margin-left: 0.00px; margin-top: -17.34px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c1">As you can see in our edited svg on the right, Cubeman is running a marathon.</span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c5">Task 4: Barycentric Coordinates </span></p><p class="c3"><span class="c1">For this task, we were given the three coordinates of the triangles, as well as their RGB color. Using interpolation, the task is to sample the pixel by the sample_rate and achieve an approximation of the color depending on its proximity to each of the three vertices. Barycentric coordinates can be used to interpolate the position or the color, and in this case we used it to get the color.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The goal was to find the alpha, beta, and gamma values and multiply them by the (x, y) coordinate for each of the vertices, so we can approximate the distance from the point being sampled to each of the three vertices. The property that allows us to do this is that alpha + beta + gamma = 1.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">We used the formulas to get this value for alpha and beta, and exploited this property to get the gamma value.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 510.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 510.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c5 c7">Task 5: &ldquo;Pixel Sampling&rdquo; for Texture Mapping</span></p><p class="c3"><span class="c1">For this task, we have to implement pixel and texture sampling to overlay a texture when rendering a triangle. Similar to the way that the sample_buffer does not map to the framebuffer when the sample_rate is more than 1, the texture coordinates do not map directly to the positions of the framebuffer, though we need to match them to properly overlay the texture. The methods to do this include the nearest sampling method and bilinear sampling. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">First, from the points that I sample, I use the barycentric triangle method to get the distance from the sample point to my coordinates in the texture space. I multiply the weights by the uv vector then for the nearest method, I scale the coordinates back to the scale of the texture space. I then use get_texel to get the associated color of the nearest point.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For the bilinear sampling method, I used the distances from the point being sampled and the vertices as weights to interpolate the color at the vertices. Once I&rsquo;ve gotten the color at the vertices, I used the s and t values, which represent the horizontal and vertical distances from the sample texture point to the sample locations, respectively. I interpolate once to get the horizontal color, and use the result of that to calculate the final vertical result, and fill in the sample_buffer accordingly.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 643.00px; height: 460.85px;"><img alt="" src="images/image7.png" style="width: 643.00px; height: 505.63px; margin-left: 0.00px; margin-top: -17.49px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c1">In these images, we can see that bilinear sampling is significantly better than nearest sampling. We can especially see this in the case that the image is warped and we need continuous samples to capture the texture of the image. We would not be able to capture this with nearest because we would get blocky results.</span></p><p class="c0"><span class="c2"></span></p><p class="c3"><span class="c5 c7">Task 6: &ldquo;Level Sampling&rdquo; with Mipmaps for Texture Mapping</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c4">Level sampling is sampling from mipmaps. Each mipmap level represents a different level of detail and contains a reduced resolution version of the original image. The algorithm to choose an appropriate mipmap is to calculate the texture coordinates, then find the partial derivatives. Then we do basic math where we take the log base 2 of the max of square sum of each partial derivatives which then returns an appropriate mipmap level. We can either choose the nearest level or apply interpolation to compute a weighted sum from each of the adjacent mipmap levels.</span></p><p class="c0"><span class="c4"></span></p><p class="c3"><span class="c4">Between the three various techniques there are tradeoffs with speed, memory usage, and antialiasing power. It is important to identify which techniques excel in the area you want to focus on. For speed, bilinear pixel sampling and level sampling are the fastest. For memory usage, level sampling is heavy on storage as it needs to store multiple mipmaps. In terms of antialiasing power, supersampling is more powerful than level sampling. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 231.12px;"><img alt="" src="images/image9.png" style="width: 307.50px; height: 231.12px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.50px; height: 222.26px;"><img alt="" src="images/image10.png" style="width: 301.50px; height: 222.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.28px; height: 222.00px;"><img alt="" src="images/image1.png" style="width: 296.28px; height: 222.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 324.00px; height: 242.71px;"><img alt="" src="images/image9.png" style="width: 324.00px; height: 242.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 323.50px; height: 240.70px;"><img alt="" src="images/image5.png" style="width: 323.50px; height: 240.70px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>